<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Proxy</title>
    </head>
    <body>
        <script>
            /*
        // 1.
        var o = {};
        var obj = new Proxy(o, {
            get(target, propertyName, receiver) {
                console.log(`getting ${propertyName} `);
                return Reflect.get(target, propertyName, receiver)
            },
            set(target, propertyName, value, receiver) {
                // console.log('receiver: ', receiver === obj);
                console.log(`setting ${propertyName} -- ${value}`);
                return Reflect.set(target, propertyName, value, receiver)
            },
        })
        obj.name = 'tom';
        obj.age = '12';
        console.log(obj.age);
        obj.count = 1;
        obj.count ++;
        console.log(obj);
        console.log(o);
        */

            /*
        // 2.proxy实例也可作为其他对象的原型对象
        var p = new Proxy({}, {
            get(target, propKey){
                return 33;
            }
        });
        var obj = Object.create(p);
        console.log(obj.s); // 33
        console.log(obj);
        */

            /*
        // 3.同一个拦截器函数，可以设置拦截多个操作：
        var handler = {
            get(target, name) {
                if(name === 'prototype') {
                    return Object.prototype;
                }
                return 'hello ' + name;
            },
            apply(target, thisBinding, args) {
                console.log(thisBinding, '====================== thisBinding'); // {a: 99}
                console.log(args, '====================== args'); // [55, 66] 
                return args[0]
            },
            construct(target, arg) {
                console.log(arg, '====================== arg');
                return { value: arg[1] };
            }
        };
        var fp = new Proxy(function(x, y) {
            return x + y;
        }, handler);

        console.log(fp, '=========fp');
        console.log(fp(2, 4)); // 2
        var s = new fp(5, 6);
        console.log(s, '=================s');
        console.log(fp.prototype === Object.prototype); // true
        console.log(fp.foo); // hello foo
        // fp.call({a: 88}, 9,7) // error: TypeError: fp.call is not a function
        console.log(' Reflect.apply(fp, {a: 99}, [55, 66]);: ',  Reflect.apply(fp, {a: 99}, [55, 66])); // 55
        */

            /**/
            // Proxy实例的方法
            // 1.get()该方法用于拦截某个属性的读取操作，可以接受三个参数，依次是目标对象，属性名和proxy实例本身（严格来说，是操作行为所针对的对象），其中最后一个参数可选。
            var person = {
                name: "张三",
            };
            var p = new Proxy(person, {
                get(target, propKey) {
                    if (propKey in target) {
                        return target[propKey];
                    }
                    // throw new ReferenceError('Prop name \'' + propKey + '\' does not exist')
                },
            });
            console.log(p.name); // 张三
            // console.log(p.a); //  ReferenceError: Prop name 'a' does not exist
            // 如果没有这个拦截函数，访问不存在的属性，只会返回undefined
            console.log(p.s); // r90 如果注释了这里是undefined
            console.log("------------------------");
            // get方法可以继承
            var proto = new Proxy(
                { a: 12 },
                {
                    get(target, propertyKey, receiver) {
                        // console.log('GET1 '+target);
                        console.log(target, "--");
                        console.log("GET2 " + propertyKey);
                        return target[propertyKey];
                    },
                }
            );
            var o = Object.create(proto, {
                name: {
                    writable: false,
                    value: "aqiuo",
                },
            });
            // console.log(o.foo); // 1 GET foo  2 undefined
            console.log(o); // ???????
            // console.log(o.__proto__ === proto, '============ compare'); // false
            // console.log(o.__proto__ === Object.prototype, '============ compare2'); // true
            // console.log(Reflect.ownKeys(o.__proto__));
            // console.log('--------------------');
            // console.log(o.name); // 读取自身的属性 不会打印 GET
            // console.log(o.a); //  读取原型上的的属性 会打印 GET a
            // 上面的代码中，拦截定义在prototype对象上面，所以如果读取o对象继承的属性时（上面是 a）,拦截会生效

            // 使用get拦截,实现数组读取负数索引
            console.log("------ 数组读取负数索引");
            function createArr(...args) {
                let handler = {
                    //    法一：直接从target中取值
                    // get(target, propKey, receiver) { // receiver proxy实例本身
                    //     let index = +propKey;
                    //     if(index < 0) {
                    //         propKey = target.length + index;
                    //     }
                    //     return target[propKey]
                    // }
                    //    法二：使用Reflect取值
                    get(target, propKey, receiver) {
                        // receiver proxy实例本身
                        let index = +propKey;
                        if (index < 0) {
                            propKey = target.length + index;
                        }
                        return Reflect.get(target, propKey, receiver);
                    },
                };
                let target = [];
                target.push(...args);
                return new Proxy(target, handler);
            }
            var arr = createArr(3, 4, 5, 6);
            console.log(arr[2]); // 5
            console.log(arr[-2]); // 5

            // 利用Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作：
            console.log("--------------- 链式操作");
            var double = (n) => n * 2;
            var pow = (n) => n * n;
            var reverseInt = (n) => String(n).split("").reverse().join("") || 0;
            var pipe = function (value) {
                var funcStack = [];
                var oproxy = new Proxy(
                    {},
                    {
                        get(pipeObj, fnName) {
                            if (fnName === "get") {
                                return funcStack.reduce((acc, fn) => {
                                    return fn(acc);
                                }, value);
                            }
                            funcStack.push(window[fnName]);
                            return oproxy;
                        },
                    }
                );
                return oproxy;
            };
            console.log(pipe(3).double.pow.reverseInt.get); // 63
            // 上面代码设置了Proxy后，达到了将函数名链式调用的效果

            // 利用get拦截，实现一个生成各种dom节点的通用函数dom;
            console.log("----------------- 通用函数dom");
            const dom = new Proxy(
                {},
                {
                    get(target, propKey) {
                        return function (attrs = {}, ...children) {
                            const el = document.createElement(propKey);
                            for (let prop of Object.keys(attrs)) {
                                el.setAttribute(prop, attrs[prop]);
                            }
                            for (let child of children) {
                                if (typeof child === "string") {
                                    child = document.createTextNode(child);
                                }
                                el.appendChild(child);
                            }
                            return el;
                        };
                    },
                }
            );
            const el = dom.div(
                {},
                "Hello, my name is ",
                dom.a({ href: "//example.com" }, "Mark"),
                ". I like:",
                dom.ul(
                    {},
                    dom.li({}, "The web"),
                    dom.li({}, "Food"),
                    dom.li({}, "…actually that's it")
                )
            );
            console.log(el);
            document.body.appendChild(el)

            // 下面是get方法的第三参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是Proxy的实例。
            

            /**/
            /**/
            /**/
        </script>
    </body>
</html>
