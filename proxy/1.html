<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Proxy</title>
    </head>
    <body>
        <script>
            //    'use strict';
            /*
            // 1.
            var o = {};
            var obj = new Proxy(o, {
                get(target, propertyName, receiver) {
                    console.log(`getting ${propertyName} `);
                    return Reflect.get(target, propertyName, receiver)
                },
                set(target, propertyName, value, receiver) {
                    // console.log('receiver: ', receiver === obj);
                    console.log(`setting ${propertyName} -- ${value}`);
                    return Reflect.set(target, propertyName, value, receiver)
                },
            })
            obj.name = 'tom';
            obj.age = '12';
            console.log(obj.age);
            obj.count = 1;
            obj.count ++;
            console.log(obj);
            console.log(o);
            */

            /*
            // 2.proxy实例也可作为其他对象的原型对象
            var p = new Proxy({}, {
                get(target, propKey){
                    return 33;
                }
            });
            var obj = Object.create(p);
            console.log(obj.s); // 33
            console.log(obj);
            */

            /*
            // 3.同一个拦截器函数，可以设置拦截多个操作：
            var handler = {
                get(target, name) {
                    if(name === 'prototype') {
                        return Object.prototype;
                    }
                    return 'hello ' + name;
                },
                apply(target, thisBinding, args) {
                    console.log(thisBinding, '====================== thisBinding'); // {a: 99}
                    console.log(args, '====================== args'); // [55, 66]
                    return args[0]
                },
                construct(target, arg) {
                    console.log(arg, '====================== arg');
                    return { value: arg[1] };
                }
            };
            var fp = new Proxy(function(x, y) {
                return x + y;
            }, handler);

            console.log(fp, '=========fp');
            console.log(fp(2, 4)); // 2
            var s = new fp(5, 6);
            console.log(s, '=================s');
            console.log(fp.prototype === Object.prototype); // true
            console.log(fp.foo); // hello foo
            // fp.call({a: 88}, 9,7) // error: TypeError: fp.call is not a function
            console.log(' Reflect.apply(fp, {a: 99}, [55, 66]);: ',  Reflect.apply(fp, {a: 99}, [55, 66])); // 55
            */

            /*
            // Proxy实例的方法
            // 1.get()该方法用于拦截某个属性的读取操作，可以接受三个参数，依次是目标对象，属性名和proxy实例本身（严格来说，是操作行为所针对的对象），其中最后一个参数可选。
            var person = {
                name: "张三",
            };
            var p = new Proxy(person, {
                get(target, propKey) {
                    if (propKey in target) {
                        return target[propKey];
                    }
                    // throw new ReferenceError('Prop name \'' + propKey + '\' does not exist')
                },
            });
            console.log(p.name); // 张三
            // console.log(p.a); //  ReferenceError: Prop name 'a' does not exist
            // 如果没有这个拦截函数，访问不存在的属性，只会返回undefined
            console.log(p.s); // r90 如果注释了这里是undefined
            console.log("------------------------");
            // get方法可以继承
            var proto = new Proxy(
                { a: 12 },
                {
                    get(target, propertyKey, receiver) {
                        // console.log('GET1 '+target);
                        console.log(target, "--");
                        console.log("GET2 " + propertyKey);
                        return target[propertyKey];
                    },
                }
            );
            var o = Object.create(proto, {
                name: {
                    writable: false,
                    value: "aqiuo",
                },
            });
            // console.log(o.foo); // 1 GET foo  2 undefined
            console.log(o); // ???????
            // console.log(o.__proto__ === proto, '============ compare'); // false
            // console.log(o.__proto__ === Object.prototype, '============ compare2'); // true
            // console.log(Reflect.ownKeys(o.__proto__));
            // console.log('--------------------');
            // console.log(o.name); // 读取自身的属性 不会打印 GET
            // console.log(o.a); //  读取原型上的的属性 会打印 GET a
            // 上面的代码中，拦截定义在prototype对象上面，所以如果读取o对象继承的属性时（上面是 a）,拦截会生效

            // 使用get拦截,实现数组读取负数索引
            console.log("------ 数组读取负数索引");
            function createArr(...args) {
                let handler = {
                    //    法一：直接从target中取值
                    // get(target, propKey, receiver) { // receiver proxy实例本身
                    //     let index = +propKey;
                    //     if(index < 0) {
                    //         propKey = target.length + index;
                    //     }
                    //     return target[propKey]
                    // }
                    //    法二：使用Reflect取值
                    get(target, propKey, receiver) {
                        // receiver proxy实例本身
                        let index = +propKey;
                        if (index < 0) {
                            propKey = target.length + index;
                        }
                        return Reflect.get(target, propKey, receiver);
                    },
                };
                let target = [];
                target.push(...args);
                return new Proxy(target, handler);
            }
            var arr = createArr(3, 4, 5, 6);
            console.log(arr[2]); // 5
            console.log(arr[-2]); // 5

            // 利用Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作：
            console.log("--------------- 链式操作");
            var double = (n) => n * 2;
            var pow = (n) => n * n;
            var reverseInt = (n) => String(n).split("").reverse().join("") || 0;
            var pipe = function (value) {
                var funcStack = [];
                var oproxy = new Proxy(
                    {},
                    {
                        get(pipeObj, fnName) {
                            if (fnName === "get") {
                                return funcStack.reduce((acc, fn) => {
                                    return fn(acc);
                                }, value);
                            }
                            funcStack.push(window[fnName]);
                            return oproxy;
                        },
                    }
                );
                return oproxy;
            };
            console.log(pipe(3).double.pow.reverseInt.get); // 63
            // 上面代码设置了Proxy后，达到了将函数名链式调用的效果

            // 利用get拦截，实现一个生成各种dom节点的通用函数dom;
            console.log("----------------- 通用函数dom");
            const dom = new Proxy(
                {},
                {
                    get(target, propKey) {
                        return function (attrs = {}, ...children) {
                            const el = document.createElement(propKey);
                            for (let prop of Object.keys(attrs)) {
                                el.setAttribute(prop, attrs[prop]);
                            }
                            for (let child of children) {
                                if (typeof child === "string") {
                                    child = document.createTextNode(child);
                                }
                                el.appendChild(child);
                            }
                            return el;
                        };
                    },
                }
            );
            const el = dom.div(
                {},
                "Hello, my name is ",
                dom.a({ href: "//example.com" }, "Mark"),
                ". I like:",
                dom.ul(
                    {},
                    dom.li({}, "The web"),
                    dom.li({}, "Food"),
                    dom.li({}, "…actually that's it")
                )
            );
            console.log(el);
            document.body.appendChild(el)

            // 下面是get方法的第三参数的例子，它总是指向原始的读操作所在的那个对象，一般情况下就是Proxy的实例。
            console.log('=================================== hr');
            let o2 = {};
            const proxy = new Proxy(o2, {
                get(target, propKey, receiver) {
                    console.log(this);
                    console.log(receiver);
                    console.log(target === o2); // true
                    console.log(receiver === this); // false
                    console.log(receiver === proxy); // true
                    return receiver;
                },
                set() {

                }
            });
            console.log(proxy.s === proxy); // true
            // 上面代码中，proxy对象的s属性是proxy提供的，所以receiver指向proxy对象

            console.log('======================== hr2');
            const p2 = new Proxy({}, {
                get(target, propKey, receiver) {
                    return receiver;
                }
            });
            const d = Object.create(p2);
            console.log(d.a === p2); // false
            console.log(d.a === d); // true
            // ** 上面代码中，d对象本身没有a属性，所以读取d.a的时候，回去d的原型p2对象上去找。这时，receiver就指向d,代码原始读操作所在的那个对象。

            // 如果一个属性不可配置*且*不可写，则Proxy不能修改该属性，否则通过Proxy对象访问该属性会报错：
            console.log('============================== hr3');
            const t = {};
            Reflect.defineProperty(t, 'foo', {
                value: 10,
                enumerable: true,
                writable: false,
                configurable: false
            });
            console.log(t, '=============t');
            const p3 = new Proxy(t, {
                get(target, key) {
                    // return 'abc' + target[key] ? target[key] : '';
                    // return target[key];
                    return 'abc' + target[key];
                }
            });
            console.log(p3.a); // 'abcundefined'
            console.log(p3.foo); // TypeError: 'get' on proxy: property 'foo' is a read-only and non-configurable data property on the proxy target but the proxy did not return its actual value (expected '10' but got 'abc')
            */

            /*
            // set():用来某个属性的赋值操作，接受四个参数，依次为目标对象，属性名， 属性值， Proxy实例本身，其中最后一个参数可选。
            // 假如person对象有个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求。
            let validator = {
                set(target, prop, value) {
                    if (prop === "age") {
                        if (!Number.isInteger(value)) {
                            throw new TypeError("value id needed Integer");
                        }
                        if (value > 200) {
                            throw new RangeError("the age seems invalid");
                        }
                        target[prop] = value;
                        return true;
                    }
                },
            };
            let person = new Proxy({}, validator);
            // person.a = 10; // 无反应
            // person.age = 310 // RangeError: the age seems invalid
            // person.age = '310' // TypeError: value id needed Integer
            person.age = -1;
            console.log(person);

            // 有时我们会在对象上设置内部属性，属性名的第一个字符串是下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以防止这些内部属性被外部读写。
            const t = {};
            let handler = {
                get(target, prop) {
                    invariant(prop, "get");
                    return target[prop];
                },
                set(target, prop, value) {
                    invariant(prop, "set");
                    target[prop] = value;
                },
            };
            const p = new Proxy(t, handler);
            function invariant(prop, action) {
                if (prop.startsWith("_")) {
                    throw new Error(
                        `Invalid attempt to ${action} privid "${prop}" property`
                    );
                }
            }

            // p._a; // Error: Invalid attempt to get privid "_a" property
            // p._a = 10; // Error: Invalid attempt to set privid "_a" property
            // 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。

            // 下面是set方法的第四个参数的例子：
            console.log("--------------------------------------h1");
            const p1 = new Proxy(
                {},
                {
                    set(target, prop, value, receiver) {
                        target[prop] = receiver;
                    },
                }
            );
            p1.foo = "aqiu";
            console.log(p1.foo === p1); // true
            // 上面代码中，set方法的第四个参数receiver，指的是原始的操作行为所在的那个对象，一般情况下是Proxy实例本身，请看下面的例子：
            const p2 = new Proxy(
                {},
                {
                    set(target, prop, value, receiver) {
                        target[prop] = receiver;
                    },
                }
            );
            let myObj = {};
            let r = Reflect.setPrototypeOf(myObj, p2);
            console.log(r, "================r"); // true
            myObj.fzz = 100;
            console.log(myObj.fzz === myObj); // true
            // 上面代码中，设置myObj.fzz属性的值时，myObj并没有fzz属性，隐藏引擎会到myObj的原型链去找fzz属性。myObj的原型对象p2是一个Proxy实例，设置它的foo属性会触发set方法，这时，第四个参数receiver就指向原始赋值行为的myObj对象。

            // 注意，如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。
            console.log("------------------------------------------ h2");
            const obj = {};
            Reflect.defineProperty(obj, "foo", {
                value: "hello",
                writable: false,
                configurable: true,
            });
            const p3 = new Proxy(obj, {
                set(target, prop, value, receiver) {
                    // "use strict";
                    console.log(prop, value, "========================898989");
                    target[prop] = value;
                    // return true
                },
            });
            console.log(p3, "==================p3");
            p3.foo = 100;
            console.log(p3.foo); // hello
            // 上面代码中，obj.foo属性不可写，Proxy对这个属性的set代理不会生效。注意严格模式下，会报错： TypeError: Cannot assign to read only property 'foo' of object '#<Object>'
            // 如果row 10 启用严格模式，则报错：TypeError: 'set' on proxy: trap returned falsish for property 'foo'
            */

            
            /*
            // apply()方法拦截函数的调用、call和apply的操作。接受三个参数，分别是目标对象，目标对象的上下文对象（this）和目标对象的参数数组。
            var handler = {
                apply(target, context, args) {
                    console.log('args: ', args);
                    console.log('context: ', context);
                    console.log('target: ', target);
                    console.log(...arguments);
                    return Reflect.apply(...arguments);
                }
            }
            // eg:
            var target = function() { return 'i am the target' };
            var handler2 = {
                apply: function() {
                    console.log(arguments);
                    return 'i am the proxy'
                }
            }
            // var p = new Proxy(target, handler);
            var p = new Proxy(target, handler2);
            // console.log('p(): ', p.apply({a: 2}, [4,5])); // i am the target
            console.log('p(): ', p.apply({a: 2}, [4,5])); // 'i am the proxy'
            // 上面代码中，变量p是Proxy的实例，当它作为函数调用时（p()）,就会被apply方法拦截，返回一个字符串。

            // 下面是另一个例子：
            console.log('-------------- h1');
            var twice = {
                apply(target, ctx, args) {
                    console.log('ctx: ', ctx); // {a: 43}
                    console.log('target: ', target); // sum
                    console.log('args: ', args); // [4, 9]
                    // return target(...args)
                    return Reflect.apply(...arguments) * 2;
                }
            }
            var sum = function(x, y) {
                return x + y;
            }
            const p2 = new Proxy(sum, twice);
            // console.log(p2(1,2)); // 6
            // console.log(p2.call(null, 4,5)); // 18
            // console.log(p2.apply(null, [5,5])); // 20
            // 另外直接调用Reflect.apply方法，也会被拦截
            var r = Reflect.apply(p2, {a: 43}, [4,9] )
            console.log('r: ', r); // 26
            */


            /*
            // has()
            // has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会很生效。典型的操作就是in运算符。
            // has方法有两个参数，分别是目标对象和要查询的属性名。
            var target = {
                _prop: 's',
                prop: 12
            };
            target.__proto__ = {a: 100}
            var handler = {
                has(target, key) {
                    if(key[0] === '_') return false;
                    // return key in target;
                    return Reflect.has(target, key);
                }
            };
            var p = new Proxy(target, handler);
            console.log('p: ', p);
            console.log('s' in p); // false
            console.log('prop' in p); // true
            console.log('_prop' in p); // false
            console.log('a' in p, '-----'); // true
            console.log('_prop' in target); // true
            // 上面代码中，如果原对象的属性名的第一个字符是下划线，p.has就会返回false,从而不被in运算符发现。

            // 如果原对象不可配置或禁止扩展，这时has会报错：
            console.log('------------------ h1');
            // var o = {a: 1};
            // Object.preventExtensions(o);

            var o = {b: 'hhh'};
            Reflect.defineProperty(o, 'a', {
                value: 100,
                configurable: false
            })

            console.log(Object.getOwnPropertyDescriptor(o, 'a'));
            const p2 = new Proxy(o, {
                has(target, key) {
                    // return key in target
                    return false
                }
            })
            console.log('b' in p2); // false
            // console.log('a' in p2); // 报错
            // 上面代码中，o对象禁止扩展，结果使用has拦截就会报错。也就是说，如果某个属性不可配置（或目标对象禁止扩展），则has方法就不得‘隐藏’（即返回false）目标对象的该属性。

            // 值得注意的是，has方法拦截的是HasProperty操作，而不是,即has方法不判断一个属性是对象自身属性还是继承属性，见row441.

            // 另外，虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效。
            console.log('------------------------- h2');
            let stu1 = { name: '张三', score: 55 };
            let stu2 = { name: '李四', score: 99 };
            let handler3 = {
                has(target, key) {
                    if(key === 'score' && target[key] < 60) {
                        console.log(`${target.name}的成绩不及格`);
                        return false
                    }
                    return key in target;
                }
            };
            let sproxy1 = new Proxy(stu1, handler3);
            let sproxy2 = new Proxy(stu2, handler3);
            console.log('score' in sproxy1); // false
            console.log('score' in sproxy2); // true

            for(let p in sproxy1) {
                console.log(p);
            }
            for(let p in sproxy2) {
                console.log(sproxy2[p]);
            }
            // 上面代码中has拦截只对in运算符生效，对for...in循环不生效，导致不符合要求的属性没被for...in循环排出掉。
            */

            /**/
            /**/
            /**/
            /**/
            /**/
            /**/
            /**/
            /**/
        </script>
    </body>
</html>
